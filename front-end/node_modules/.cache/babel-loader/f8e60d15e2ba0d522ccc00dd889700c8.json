{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport isRetryAllowed from 'is-retry-allowed';\nexport var namespace = 'axios-retry';\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\n\nexport function isNetworkError(error) {\n  var CODE_EXCLUDE_LIST = ['ERR_CANCELED', 'ECONNABORTED'];\n  return !error.response && Boolean(error.code) && // Prevents retrying cancelled requests\n  !CODE_EXCLUDE_LIST.includes(error.code) && // Prevents retrying timed out & cancelled requests\n  isRetryAllowed(error) // Prevents retrying unsafe errors\n  ;\n}\nvar SAFE_HTTP_METHODS = ['get', 'head', 'options'];\nvar IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\n\nexport function isRetryableError(error) {\n  return error.code !== 'ECONNABORTED' && (!error.response || error.response.status >= 500 && error.response.status <= 599);\n}\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\n\nexport function isSafeRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\n\nexport function isIdempotentRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\n\nexport function isNetworkOrIdempotentRequestError(error) {\n  return isNetworkError(error) || isIdempotentRequestError(error);\n}\n/**\n * @return {number} - delay in milliseconds, always 0\n */\n\nfunction noDelay() {\n  return 0;\n}\n/**\n * Set delayFactor 1000 for an exponential delay to occur on the order\n * of seconds\n * @param  {number} [retryNumber=0]\n * @param  {Error}  error - unused; for existing API of retryDelay callback\n * @param  {number} [delayFactor=100] milliseconds\n * @return {number} - delay in milliseconds\n */\n\n\nexport function exponentialDelay() {\n  var retryNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var error = arguments.length > 1 ? arguments[1] : undefined;\n  var delayFactor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n  var delay = Math.pow(2, retryNumber) * delayFactor;\n  var randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay\n\n  return delay + randomSum;\n}\n/** @type {IAxiosRetryConfig} */\n\nexport var DEFAULT_OPTIONS = {\n  retries: 3,\n  retryCondition: isNetworkOrIdempotentRequestError,\n  retryDelay: noDelay,\n  shouldResetTimeout: false,\n  onRetry: () => {}\n};\n/**\n * Returns the axios-retry options for the current request\n * @param  {AxiosRequestConfig} config\n * @param  {IAxiosRetryConfig} defaultOptions\n * @return {IAxiosRetryConfigExtended}\n */\n\nfunction getRequestOptions(config, defaultOptions) {\n  return _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_OPTIONS), defaultOptions), config[namespace]);\n}\n/**\n * Initializes and returns the retry state for the given request/config\n * @param  {AxiosRequestConfig} config\n * @param  {IAxiosRetryConfig} defaultOptions\n * @return {IAxiosRetryConfigExtended}\n */\n\n\nfunction getCurrentState(config, defaultOptions) {\n  var currentState = getRequestOptions(config, defaultOptions);\n  currentState.retryCount = currentState.retryCount || 0;\n  config[namespace] = currentState;\n  return currentState;\n}\n/**\n * @param  {Axios} axios\n * @param  {AxiosRequestConfig} config\n */\n\n\nfunction fixConfig(axios, config) {\n  if (axios.defaults.agent === config.agent) {\n    delete config.agent;\n  }\n\n  if (axios.defaults.httpAgent === config.httpAgent) {\n    delete config.httpAgent;\n  }\n\n  if (axios.defaults.httpsAgent === config.httpsAgent) {\n    delete config.httpsAgent;\n  }\n}\n/**\n * Checks retryCondition if request can be retried. Handles it's returning value or Promise.\n * @param  {IAxiosRetryConfigExtended} currentState\n * @param  {Error} error\n * @return {Promise<boolean>}\n */\n\n\nfunction shouldRetry(_x, _x2) {\n  return _shouldRetry.apply(this, arguments);\n}\n/**\n * Adds response interceptors to an axios instance to retry requests failed due to network issues\n *\n * @example\n *\n * import axios from 'axios';\n *\n * axiosRetry(axios, { retries: 3 });\n *\n * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Exponential back-off retry delay between requests\n * axiosRetry(axios, { retryDelay : axiosRetry.exponentialDelay});\n *\n * // Custom retry delay\n * axiosRetry(axios, { retryDelay : (retryCount) => {\n *   return retryCount * 1000;\n * }});\n *\n * // Also works with custom axios instances\n * const client = axios.create({ baseURL: 'http://example.com' });\n * axiosRetry(client, { retries: 3 });\n *\n * client.get('/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Allows request-specific configuration\n * client\n *   .get('/test', {\n *     'axios-retry': {\n *       retries: 0\n *     }\n *   })\n *   .catch(error => { // The first request fails\n *     error !== undefined\n *   });\n *\n * @param {Axios} axios An axios instance (the axios object or one created from axios.create)\n * @param {Object} [defaultOptions]\n * @param {number} [defaultOptions.retries=3] Number of retries\n * @param {boolean} [defaultOptions.shouldResetTimeout=false]\n *        Defines if the timeout should be reset between retries\n * @param {Function} [defaultOptions.retryCondition=isNetworkOrIdempotentRequestError]\n *        A function to determine if the error can be retried\n * @param {Function} [defaultOptions.retryDelay=noDelay]\n *        A function to determine the delay between retry requests\n * @param {Function} [defaultOptions.onRetry=()=>{}]\n *        A function to get notified when a retry occurs\n * @return {{ requestInterceptorId: number, responseInterceptorId: number }}\n *        The ids of the interceptors added to the request and to the response (so they can be ejected at a later time)\n */\n\n\nfunction _shouldRetry() {\n  _shouldRetry = _asyncToGenerator(function* (currentState, error) {\n    var {\n      retries,\n      retryCondition\n    } = currentState;\n    var shouldRetryOrPromise = currentState.retryCount < retries && retryCondition(error); // This could be a promise\n\n    if (typeof shouldRetryOrPromise === 'object') {\n      try {\n        var shouldRetryPromiseResult = yield shouldRetryOrPromise; // keep return true unless shouldRetryPromiseResult return false for compatibility\n\n        return shouldRetryPromiseResult !== false;\n      } catch (_err) {\n        return false;\n      }\n    }\n\n    return shouldRetryOrPromise;\n  });\n  return _shouldRetry.apply(this, arguments);\n}\n\nexport default function axiosRetry(axios, defaultOptions) {\n  var requestInterceptorId = axios.interceptors.request.use(config => {\n    var currentState = getCurrentState(config, defaultOptions);\n    currentState.lastRequestTime = Date.now();\n    return config;\n  });\n  var responseInterceptorId = axios.interceptors.response.use(null, /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (error) {\n      var {\n        config\n      } = error; // If we have no information to retry the request\n\n      if (!config) {\n        return Promise.reject(error);\n      }\n\n      var currentState = getCurrentState(config, defaultOptions);\n\n      if (yield shouldRetry(currentState, error)) {\n        currentState.retryCount += 1;\n        var {\n          retryDelay,\n          shouldResetTimeout,\n          onRetry\n        } = currentState;\n        var delay = retryDelay(currentState.retryCount, error); // Axios fails merging this configuration to the default configuration because it has an issue\n        // with circular structures: https://github.com/mzabriskie/axios/issues/370\n\n        fixConfig(axios, config);\n\n        if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {\n          var lastRequestDuration = Date.now() - currentState.lastRequestTime;\n          var timeout = config.timeout - lastRequestDuration - delay;\n\n          if (timeout <= 0) {\n            return Promise.reject(error);\n          }\n\n          config.timeout = timeout;\n        }\n\n        config.transformRequest = [data => data];\n        yield onRetry(currentState.retryCount, error, config);\n        return new Promise(resolve => setTimeout(() => resolve(axios(config)), delay));\n      }\n\n      return Promise.reject(error);\n    });\n\n    return function (_x3) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n  return {\n    requestInterceptorId,\n    responseInterceptorId\n  };\n} // Compatibility with CommonJS\n\naxiosRetry.isNetworkError = isNetworkError;\naxiosRetry.isSafeRequestError = isSafeRequestError;\naxiosRetry.isIdempotentRequestError = isIdempotentRequestError;\naxiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;\naxiosRetry.exponentialDelay = exponentialDelay;\naxiosRetry.isRetryableError = isRetryableError;","map":{"version":3,"sources":["../../es/index.mjs"],"names":["namespace","CODE_EXCLUDE_LIST","error","Boolean","isRetryAllowed","SAFE_HTTP_METHODS","IDEMPOTENT_HTTP_METHODS","isRetryableError","isNetworkError","isIdempotentRequestError","retryNumber","delayFactor","delay","Math","randomSum","DEFAULT_OPTIONS","retries","retryCondition","retryDelay","shouldResetTimeout","onRetry","config","currentState","getRequestOptions","axios","shouldRetry","shouldRetryOrPromise","shouldRetryPromiseResult","requestInterceptorId","getCurrentState","Date","responseInterceptorId","Promise","fixConfig","lastRequestDuration","timeout","data","resolve","setTimeout","axiosRetry"],"mappings":"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","sourcesContent":["import isRetryAllowed from 'is-retry-allowed';\n\nexport const namespace = 'axios-retry';\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isNetworkError(error) {\n  const CODE_EXCLUDE_LIST = ['ERR_CANCELED', 'ECONNABORTED'];\n\n  return (\n    !error.response &&\n    Boolean(error.code) && // Prevents retrying cancelled requests\n    !CODE_EXCLUDE_LIST.includes(error.code) && // Prevents retrying timed out & cancelled requests\n    isRetryAllowed(error) // Prevents retrying unsafe errors\n  );\n}\n\nconst SAFE_HTTP_METHODS = ['get', 'head', 'options'];\nconst IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isRetryableError(error) {\n  return (\n    error.code !== 'ECONNABORTED' &&\n    (!error.response || (error.response.status >= 500 && error.response.status <= 599))\n  );\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isSafeRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isIdempotentRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isNetworkOrIdempotentRequestError(error) {\n  return isNetworkError(error) || isIdempotentRequestError(error);\n}\n\n/**\n * @return {number} - delay in milliseconds, always 0\n */\nfunction noDelay() {\n  return 0;\n}\n\n/**\n * Set delayFactor 1000 for an exponential delay to occur on the order\n * of seconds\n * @param  {number} [retryNumber=0]\n * @param  {Error}  error - unused; for existing API of retryDelay callback\n * @param  {number} [delayFactor=100] milliseconds\n * @return {number} - delay in milliseconds\n */\nexport function exponentialDelay(retryNumber = 0, error, delayFactor = 100) {\n  const delay = Math.pow(2, retryNumber) * delayFactor;\n  const randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay\n  return delay + randomSum;\n}\n\n/** @type {IAxiosRetryConfig} */\nexport const DEFAULT_OPTIONS = {\n  retries: 3,\n  retryCondition: isNetworkOrIdempotentRequestError,\n  retryDelay: noDelay,\n  shouldResetTimeout: false,\n  onRetry: () => {}\n};\n\n/**\n * Returns the axios-retry options for the current request\n * @param  {AxiosRequestConfig} config\n * @param  {IAxiosRetryConfig} defaultOptions\n * @return {IAxiosRetryConfigExtended}\n */\nfunction getRequestOptions(config, defaultOptions) {\n  return { ...DEFAULT_OPTIONS, ...defaultOptions, ...config[namespace] };\n}\n\n/**\n * Initializes and returns the retry state for the given request/config\n * @param  {AxiosRequestConfig} config\n * @param  {IAxiosRetryConfig} defaultOptions\n * @return {IAxiosRetryConfigExtended}\n */\nfunction getCurrentState(config, defaultOptions) {\n  const currentState = getRequestOptions(config, defaultOptions);\n  currentState.retryCount = currentState.retryCount || 0;\n  config[namespace] = currentState;\n  return currentState;\n}\n\n/**\n * @param  {Axios} axios\n * @param  {AxiosRequestConfig} config\n */\nfunction fixConfig(axios, config) {\n  if (axios.defaults.agent === config.agent) {\n    delete config.agent;\n  }\n  if (axios.defaults.httpAgent === config.httpAgent) {\n    delete config.httpAgent;\n  }\n  if (axios.defaults.httpsAgent === config.httpsAgent) {\n    delete config.httpsAgent;\n  }\n}\n\n/**\n * Checks retryCondition if request can be retried. Handles it's returning value or Promise.\n * @param  {IAxiosRetryConfigExtended} currentState\n * @param  {Error} error\n * @return {Promise<boolean>}\n */\nasync function shouldRetry(currentState, error) {\n  const { retries, retryCondition } = currentState;\n  const shouldRetryOrPromise = currentState.retryCount < retries && retryCondition(error);\n\n  // This could be a promise\n  if (typeof shouldRetryOrPromise === 'object') {\n    try {\n      const shouldRetryPromiseResult = await shouldRetryOrPromise;\n      // keep return true unless shouldRetryPromiseResult return false for compatibility\n      return shouldRetryPromiseResult !== false;\n    } catch (_err) {\n      return false;\n    }\n  }\n  return shouldRetryOrPromise;\n}\n\n/**\n * Adds response interceptors to an axios instance to retry requests failed due to network issues\n *\n * @example\n *\n * import axios from 'axios';\n *\n * axiosRetry(axios, { retries: 3 });\n *\n * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Exponential back-off retry delay between requests\n * axiosRetry(axios, { retryDelay : axiosRetry.exponentialDelay});\n *\n * // Custom retry delay\n * axiosRetry(axios, { retryDelay : (retryCount) => {\n *   return retryCount * 1000;\n * }});\n *\n * // Also works with custom axios instances\n * const client = axios.create({ baseURL: 'http://example.com' });\n * axiosRetry(client, { retries: 3 });\n *\n * client.get('/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Allows request-specific configuration\n * client\n *   .get('/test', {\n *     'axios-retry': {\n *       retries: 0\n *     }\n *   })\n *   .catch(error => { // The first request fails\n *     error !== undefined\n *   });\n *\n * @param {Axios} axios An axios instance (the axios object or one created from axios.create)\n * @param {Object} [defaultOptions]\n * @param {number} [defaultOptions.retries=3] Number of retries\n * @param {boolean} [defaultOptions.shouldResetTimeout=false]\n *        Defines if the timeout should be reset between retries\n * @param {Function} [defaultOptions.retryCondition=isNetworkOrIdempotentRequestError]\n *        A function to determine if the error can be retried\n * @param {Function} [defaultOptions.retryDelay=noDelay]\n *        A function to determine the delay between retry requests\n * @param {Function} [defaultOptions.onRetry=()=>{}]\n *        A function to get notified when a retry occurs\n * @return {{ requestInterceptorId: number, responseInterceptorId: number }}\n *        The ids of the interceptors added to the request and to the response (so they can be ejected at a later time)\n */\nexport default function axiosRetry(axios, defaultOptions) {\n  const requestInterceptorId = axios.interceptors.request.use((config) => {\n    const currentState = getCurrentState(config, defaultOptions);\n    currentState.lastRequestTime = Date.now();\n    return config;\n  });\n\n  const responseInterceptorId = axios.interceptors.response.use(null, async (error) => {\n    const { config } = error;\n\n    // If we have no information to retry the request\n    if (!config) {\n      return Promise.reject(error);\n    }\n\n    const currentState = getCurrentState(config, defaultOptions);\n\n    if (await shouldRetry(currentState, error)) {\n      currentState.retryCount += 1;\n      const { retryDelay, shouldResetTimeout, onRetry } = currentState;\n      const delay = retryDelay(currentState.retryCount, error);\n\n      // Axios fails merging this configuration to the default configuration because it has an issue\n      // with circular structures: https://github.com/mzabriskie/axios/issues/370\n      fixConfig(axios, config);\n\n      if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {\n        const lastRequestDuration = Date.now() - currentState.lastRequestTime;\n        const timeout = config.timeout - lastRequestDuration - delay;\n        if (timeout <= 0) {\n          return Promise.reject(error);\n        }\n        config.timeout = timeout;\n      }\n\n      config.transformRequest = [(data) => data];\n\n      await onRetry(currentState.retryCount, error, config);\n\n      return new Promise((resolve) => setTimeout(() => resolve(axios(config)), delay));\n    }\n\n    return Promise.reject(error);\n  });\n\n  return { requestInterceptorId, responseInterceptorId };\n}\n\n// Compatibility with CommonJS\naxiosRetry.isNetworkError = isNetworkError;\naxiosRetry.isSafeRequestError = isSafeRequestError;\naxiosRetry.isIdempotentRequestError = isIdempotentRequestError;\naxiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;\naxiosRetry.exponentialDelay = exponentialDelay;\naxiosRetry.isRetryableError = isRetryableError;\n"]},"metadata":{},"sourceType":"module"}