{"ast":null,"code":"'use strict';\n\nvar forEach = require('for-each');\n\nvar availableTypedArrays = require('available-typed-arrays');\n\nvar callBind = require('call-bind');\n\nvar callBound = require('call-bind/callBound');\n\nvar gOPD = require('gopd');\n/** @type {(O: object) => string} */\n\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\nvar $slice = callBound('String.prototype.slice');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\n\n/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n  for (var i = 0; i < array.length; i += 1) {\n    if (array[i] === value) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/** @typedef {(receiver: import('.').TypedArray) => string | typeof Uint8Array.prototype.slice.call | typeof Uint8Array.prototype.set.call} Getter */\n\n/** @type {{ [k in `\\$${import('.').TypedArrayName}`]?: Getter } & { __proto__: null }} */\n\n\nvar cache = {\n  __proto__: null\n};\n\nif (hasToStringTag && gOPD && getPrototypeOf) {\n  forEach(typedArrays, function (typedArray) {\n    var arr = new g[typedArray]();\n\n    if (Symbol.toStringTag in arr) {\n      var proto = getPrototypeOf(arr); // @ts-expect-error TS won't narrow inside a closure\n\n      var descriptor = gOPD(proto, Symbol.toStringTag);\n\n      if (!descriptor) {\n        var superProto = getPrototypeOf(proto); // @ts-expect-error TS won't narrow inside a closure\n\n        descriptor = gOPD(superProto, Symbol.toStringTag);\n      } // @ts-expect-error TODO: fix\n\n\n      cache['$' + typedArray] = callBind(descriptor.get);\n    }\n  });\n} else {\n  forEach(typedArrays, function (typedArray) {\n    var arr = new g[typedArray]();\n    var fn = arr.slice || arr.set;\n\n    if (fn) {\n      // @ts-expect-error TODO: fix\n      cache['$' + typedArray] = callBind(fn);\n    }\n  });\n}\n/** @type {(value: object) => false | import('.').TypedArrayName} */\n\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n  /** @type {ReturnType<typeof tryAllTypedArrays>} */\n  var found = false;\n  forEach( // eslint-disable-next-line no-extra-parens\n\n  /** @type {Record<`\\$${TypedArrayName}`, Getter>} */\n\n  /** @type {any} */\n  cache,\n  /** @type {(getter: Getter, name: `\\$${import('.').TypedArrayName}`) => void} */\n  function (getter, typedArray) {\n    if (!found) {\n      try {\n        // @ts-expect-error TODO: fix\n        if ('$' + getter(value) === typedArray) {\n          found = $slice(typedArray, 1);\n        }\n      } catch (e) {\n        /**/\n      }\n    }\n  });\n  return found;\n};\n/** @type {(value: object) => false | import('.').TypedArrayName} */\n\n\nvar trySlices = function tryAllSlices(value) {\n  /** @type {ReturnType<typeof tryAllSlices>} */\n  var found = false;\n  forEach( // eslint-disable-next-line no-extra-parens\n\n  /** @type {Record<`\\$${TypedArrayName}`, Getter>} */\n\n  /** @type {any} */\n  cache,\n  /** @type {(getter: typeof cache, name: `\\$${import('.').TypedArrayName}`) => void} */\n  function (getter, name) {\n    if (!found) {\n      try {\n        // @ts-expect-error TODO: fix\n        getter(value);\n        found = $slice(name, 1);\n      } catch (e) {\n        /**/\n      }\n    }\n  });\n  return found;\n};\n/** @type {import('.')} */\n\n\nmodule.exports = function whichTypedArray(value) {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n\n  if (!hasToStringTag) {\n    /** @type {string} */\n    var tag = $slice($toString(value), 8, -1);\n\n    if ($indexOf(typedArrays, tag) > -1) {\n      return tag;\n    }\n\n    if (tag !== 'Object') {\n      return false;\n    } // node < 0.6 hits here on real Typed Arrays\n\n\n    return trySlices(value);\n  }\n\n  if (!gOPD) {\n    return null;\n  } // unknown engine\n\n\n  return tryTypedArrays(value);\n};","map":{"version":3,"sources":["C:/aria/cicc-app/front-end/node_modules/which-typed-array/index.js"],"names":["forEach","require","availableTypedArrays","callBind","callBound","gOPD","$toString","hasToStringTag","g","globalThis","global","typedArrays","$slice","getPrototypeOf","Object","$indexOf","indexOf","array","value","i","length","cache","__proto__","typedArray","arr","Symbol","toStringTag","proto","descriptor","superProto","get","fn","slice","set","tryTypedArrays","tryAllTypedArrays","found","getter","e","trySlices","tryAllSlices","name","module","exports","whichTypedArray","tag"],"mappings":"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","sourcesContent":["'use strict';\n\nvar forEach = require('for-each');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBind = require('call-bind');\nvar callBound = require('call-bind/callBound');\nvar gOPD = require('gopd');\n\n/** @type {(O: object) => string} */\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\n\n/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n/** @typedef {(receiver: import('.').TypedArray) => string | typeof Uint8Array.prototype.slice.call | typeof Uint8Array.prototype.set.call} Getter */\n/** @type {{ [k in `\\$${import('.').TypedArrayName}`]?: Getter } & { __proto__: null }} */\nvar cache = { __proto__: null };\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t// @ts-expect-error TS won't narrow inside a closure\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t// @ts-expect-error TS won't narrow inside a closure\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\t// @ts-expect-error TODO: fix\n\t\t\tcache['$' + typedArray] = callBind(descriptor.get);\n\t\t}\n\t});\n} else {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tvar fn = arr.slice || arr.set;\n\t\tif (fn) {\n\t\t\t// @ts-expect-error TODO: fix\n\t\t\tcache['$' + typedArray] = callBind(fn);\n\t\t}\n\t});\n}\n\n/** @type {(value: object) => false | import('.').TypedArrayName} */\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\t/** @type {ReturnType<typeof tryAllTypedArrays>} */ var found = false;\n\tforEach(\n\t\t// eslint-disable-next-line no-extra-parens\n\t\t/** @type {Record<`\\$${TypedArrayName}`, Getter>} */ /** @type {any} */ (cache),\n\t\t/** @type {(getter: Getter, name: `\\$${import('.').TypedArrayName}`) => void} */\n\t\tfunction (getter, typedArray) {\n\t\t\tif (!found) {\n\t\t\t\ttry {\n\t\t\t\t// @ts-expect-error TODO: fix\n\t\t\t\t\tif ('$' + getter(value) === typedArray) {\n\t\t\t\t\t\tfound = $slice(typedArray, 1);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) { /**/ }\n\t\t\t}\n\t\t}\n\t);\n\treturn found;\n};\n\n/** @type {(value: object) => false | import('.').TypedArrayName} */\nvar trySlices = function tryAllSlices(value) {\n\t/** @type {ReturnType<typeof tryAllSlices>} */ var found = false;\n\tforEach(\n\t\t// eslint-disable-next-line no-extra-parens\n\t\t/** @type {Record<`\\$${TypedArrayName}`, Getter>} */ /** @type {any} */ (cache),\n\t\t/** @type {(getter: typeof cache, name: `\\$${import('.').TypedArrayName}`) => void} */ function (getter, name) {\n\t\t\tif (!found) {\n\t\t\t\ttry {\n\t\t\t\t\t// @ts-expect-error TODO: fix\n\t\t\t\t\tgetter(value);\n\t\t\t\t\tfound = $slice(name, 1);\n\t\t\t\t} catch (e) { /**/ }\n\t\t\t}\n\t\t}\n\t);\n\treturn found;\n};\n\n/** @type {import('.')} */\nmodule.exports = function whichTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag) {\n\t\t/** @type {string} */\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\tif ($indexOf(typedArrays, tag) > -1) {\n\t\t\treturn tag;\n\t\t}\n\t\tif (tag !== 'Object') {\n\t\t\treturn false;\n\t\t}\n\t\t// node < 0.6 hits here on real Typed Arrays\n\t\treturn trySlices(value);\n\t}\n\tif (!gOPD) { return null; } // unknown engine\n\treturn tryTypedArrays(value);\n};\n"]},"metadata":{},"sourceType":"script"}